#ifndef TOKEN_CONSTANTS_HPP
#define TOKEN_CONSTANTS_HPP

#include <string>
#include <unordered_map>

namespace core {

	enum LexTokenType {
		TK_BOOL_LITERAL,
		TK_INT_LITERAL,
		TK_FLOAT_LITERAL,
		TK_CHAR_LITERAL,
		TK_STRING_LITERAL,
		TK_ADDITIVE_OP,
		TK_EXPONENTIATION_OP,
		TK_INCREMENT_OP,
		TK_MULTIPLICATIVE_OP,
		TK_RELATIONAL_OP,
		TK_THREE_WAY_OP,
		TK_EQUALITY_OP,
		TK_LOGICAL_AND_OP,
		TK_LOGICAL_OR_OP,
		TK_NOT,
		TK_VOID_TYPE,
		TK_BOOL_TYPE,
		TK_INT_TYPE,
		TK_FLOAT_TYPE,
		TK_CHAR_TYPE,
		TK_STRING_TYPE,
		TK_ANY_TYPE,
		TK_FUNCTION_TYPE,
		TK_TYPEOF,
		TK_TYPEID,
		TK_REFID,
		TK_IS_STRUCT,
		TK_IS_ARRAY,
		TK_IS_ANY,
		TK_USING,
		TK_ENUM,
		TK_NAMESPACE,
		TK_CONST,
		TK_VAR,
		TK_REF,
		TK_UNREF,
		TK_STRUCT,
		TK_FUN,
		TK_LAMBDA,
		TK_NULL,
		TK_THIS,
		TK_RETURN,
		TK_CONTINUE,
		TK_BREAK,
		TK_EXIT,
		TK_TRY,
		TK_CATCH,
		TK_THROW,
		TK_SWITCH,
		TK_CASE,
		TK_DEFAULT,
		TK_INCLUDE,
		TK_EXCLUDE,
		TK_IS,
		TK_IN,
		TK_IF,
		TK_ELSE,
		TK_FOR,
		TK_FOREACH,
		TK_WHILE,
		TK_DO,
		TK_IDENTIFIER,
		TK_EQUALS,
		TK_LIB_ACESSOR_OP,
		TK_ELLIPSIS,
		TK_LEFT_CURLY,
		TK_RIGHT_CURLY,
		TK_LEFT_BRACKET,
		TK_RIGHT_BRACKET,
		TK_LEFT_BRACE,
		TK_RIGHT_BRACE,
		TK_COMMA,
		TK_DOT,
		TK_SEMICOLON,
		TK_COLON,
		TK_QMARK,
		TK_DSIGN,
		TK_BITWISE_OR,
		TK_BITWISE_XOR,
		TK_BITWISE_AND,
		TK_BITWISE_SHIFT,
		TK_COMMENT,
		TK_ERROR,
		TK_EOF
	};

	inline const std::unordered_map<LexTokenType, std::string> TOKEN_IMAGE = {
		{TK_BOOL_LITERAL, "<bool literal>"},
		{TK_INT_LITERAL, "<int literal>"},
		{TK_FLOAT_LITERAL, "<float literal>"},
		{TK_CHAR_LITERAL, "<char literal>"},
		{TK_STRING_LITERAL, "<string literal>"},
		{TK_ADDITIVE_OP, "<additive operator>"},
		{TK_EXPONENTIATION_OP, "<unary exponentiation operator>"},
		{TK_INCREMENT_OP, "<unary additive operator>"},
		{TK_MULTIPLICATIVE_OP, "<multiplicative operator>"},
		{TK_RELATIONAL_OP, "<relational operator>"},
		{TK_THREE_WAY_OP, "<=>"},
		{TK_EQUALITY_OP, "<equality operator>"},
		{TK_LOGICAL_AND_OP, "and"},
		{TK_LOGICAL_OR_OP, "or"},
		{TK_NOT, "not"},
		{TK_VOID_TYPE, "void"},
		{TK_BOOL_TYPE, "bool"},
		{TK_INT_TYPE, "int"},
		{TK_FLOAT_TYPE, "float"},
		{TK_CHAR_TYPE, "char"},
		{TK_STRING_TYPE, "string"},
		{TK_ANY_TYPE, "any"},
		{TK_FUNCTION_TYPE, "function"},
		{TK_TYPEOF, "typeof"},
		{TK_TYPEID, "typeid"},
		{TK_REFID, "refid"},
		{TK_IS_STRUCT, "is_struct"},
		{TK_IS_ARRAY, "is_array"},
		{TK_IS_ANY, "is_any"},
		{TK_USING, "using"},
		{TK_ENUM, "enum"},
		{TK_NAMESPACE, "namespace"},
		{TK_CONST, "const"},
		{TK_VAR, "var"},
		{TK_REF, "ref"},
		{TK_UNREF, "unref"},
		{TK_STRUCT, "struct"},
		{TK_FUN, "fun"},
		{TK_LAMBDA, "lambda"},
		{TK_NULL, "null"},
		{TK_THIS, "this"},
		{TK_RETURN, "return"},
		{TK_CONTINUE, "continue"},
		{TK_BREAK, "break"},
		{TK_EXIT, "exit"},
		{TK_TRY, "try"},
		{TK_CATCH, "catch"},
		{TK_THROW, "throw"},
		{TK_SWITCH, "switch"},
		{TK_CASE, "case"},
		{TK_DEFAULT, "default"},
		{TK_INCLUDE, "include"},
		{TK_EXCLUDE, "exclude"},
		{TK_IS, "is"},
		{TK_IN, "in"},
		{TK_IF, "if"},
		{TK_ELSE, "else"},
		{TK_FOR, "for"},
		{TK_FOREACH, "foreach"},
		{TK_WHILE, "while"},
		{TK_DO, "do"},
		{TK_IDENTIFIER, "identifier"},
		{TK_EQUALS, "="},
		{TK_LIB_ACESSOR_OP, "::"},
		{TK_ELLIPSIS, "..."},
		{TK_LEFT_CURLY, "{"},
		{TK_RIGHT_CURLY, "}"},
		{TK_LEFT_BRACKET, "("},
		{TK_RIGHT_BRACKET, ")"},
		{TK_LEFT_BRACE, "["},
		{TK_RIGHT_BRACE, "]"},
		{TK_COMMA, ","},
		{TK_DOT, "."},
		{TK_SEMICOLON, ";"},
		{TK_COLON, ":"},
		{TK_QMARK, "?"},
		{TK_DSIGN, "$"},
		{TK_BITWISE_OR, "|"},
		{TK_BITWISE_XOR, "^"},
		{TK_BITWISE_AND, "&"},
		{TK_BITWISE_SHIFT, "<bitwise shift operator>"},
		{TK_COMMENT, "<commentary>"},
		{TK_ERROR, "<ERROR>"},
		{TK_EOF, "<EOF>"}
	};

}

#endif // !TOKEN_CONSTANTS_HPP
